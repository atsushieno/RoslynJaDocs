原文：[How to Contribute](http://roslyn.codeplex.com/wikipage?title=How%20to%20Contribute)

# コードに対する貢献

新機能あるいは既存のコードに対するコードを送信する前に、
まずはチームと[議論](https://roslyn.codeplex.com/discussions)を交わして、
[製品ロードマップ](roadmap.md)に適合しているかどうか
確認するようにしてください。
送信するコードには非常に高い品質、設計、および
ロードマップに対する適合性が要求されます。

現在のところ、チームではプルリクエストに以下の条件を課しています：

* バグフィックスのレベルを超えるものについてはまずチームとの
  [議論](https://roslyn.codeplex.com/discussions)を行い、
  それが無かった場合にはリクエストを破棄します。
  我々のプロセスが成熟して経験も豊富になるにつれて、
  チームはより大きな貢献を期待するようになるでしょう。
* マスターブランチに対するものだけが受け入れられます。
  試験的機能用のブランチやリリースブランチをターゲットにした
  プルリクエストを作成した場合、代わりにマスターブランチに対する
  プルリクエストにならないかどうか問い合わせをされることになります。
* 最新のマスターブランチに簡単にマージできないようなプルリクエストは破棄されます。
  リクエスト作成者は最新のマスターにマージできるような新しいプルリクエストを
  要求されることがあります。
* 提案するコードでは機能およびパフォーマンスにおける要求事項を満たすこと。
  これにはまだオープンソースによるテストがチームによって
  実装されていない部分も含まれます。
  つまり新しく実装されたテストのいずれかでエラーとなるような場合、
  プルリクエストを修正して再提出するよう要求されることがあります。

変更作業を続ける準備が出来れば、コードを[ビルド](build.md)する用意をして、
我々のワークフローおよびコーディング基準に慣れてください。
Miguel de Icazaによる
[Open Source Contribution Etiquette](http://tirania.org/blog/archive/2010/Dec-31.html)
と
Ilya Grigorikによる
[Don't "Push" Your Pull Requests](http://www.igvita.com/2011/12/19/dont-push-your-pull-requests/)
という2つのブログ記事もオープンソースプロジェクトに
コードを貢献する際に役立つことでしょう。

プルリクエストを送信する前には必ず
[Contributor License Agreement](https://cla.msopentech.com/) (CLA) 
にサインする必要があります。
CLAを完了するには[フォーム](https://cla.msopentech.com/)からリクエストを送信して、
受信したメールに記述されたリンクの先にあるドキュメントに
電子署名をする必要があります。
CLAの手続きが必要になるのは1度だけです。
1度行えばすべてのMicrosoft Open Technologies OSSプロジェクトに参加できます。

## 開発者用ワークフロー

1. トリアージプロセスにおいて作業項目が開発者に割り当てられます。
2. Microsoft Open Techの開発者がブランチ上で作業を進めます。
   あるいは外部コントリビューターがフォーク上で作業を進めます。
   ツリーをきれいな状態に保ち、不要なマージ操作が必要にならないようにするためにも、
   できるだけrebaseするようにしてください。
   pullおよびrebaseを頻繁に行うようにすることで、
   マージ時の競合を最小限に抑えられるでしょう。
3. Microsoft Open Techの開発者は内部コードレビューシステムを使用することになります。
   外部コントリビューターの場合はフォークをサーバーにpushした後、
   コードレビュープロセスを開始できるようにプルリクエストを送信します。
4. コードレビュープロセスが完了して変更が許可されると、
   チームのメンバーがマスターブランチに変更をpushします。

## 新しい課題の作成

新しい課題を[issue tracker](https://roslyn.codeplex.com/workitem/list/basic)
で作成する場合、以下のガイドラインに従ってください：

* 指摘する問題、あるいは要求する機能を識別できるようなわかりやすいタイトルを
  付けてください。
  たとえばコンパイラーが意図したとおりに動作しない問題を指摘する場合、
  バグのタイトルにはコンパイラーがどのように**動作している**のかではなく、
  どのように**動作すべき**なのかを記述してください。
  "C# compiler should report CS1234 when Xyz is used in Abcd."
  (C#コンパイラーはXyzがAbcd内で使用された場合、CS1234を報告するべき。)
* Impact以外のバグ項目を設定しないでください。
* 問題点あるいは要求する機能について、詳しい説明を記載してください。
* バグレポートの場合、さらに以下を行ってください：
  * 期待する動作と実際の動作を説明してください。
    クラッシュするなど、自分で説明がつかないような場合には
    何故期待する動作が期待されるのかを説明してください。
  * 問題を再現できるコードを記述してください。
  * 関連する例外メッセージおよびスタックトレースを記述してください。
* フォローアップ用の質問に答えられるよう、作成した課題を購読するようにしてください。

## トリアージプロセス

チームでは[issue tracker](https://roslyn.codeplex.com/workitem/list/basic)
上において、以下のワークフローでバグをトリアージ(分類)しています：

1. 新しい課題が**Proposed**の状態でオープンされます。
2. 新しい課題がトリアージされて、トリアージチームが
   その課題に対する変更、あるいはより深い検討が必要だと判断した場合には
   **Proposed**から**Active**の状態に変更されます。
   トリアージチームは日々課題をトリアージするようにしています。
3. 開発者が課題に対する作業を開始する際には、バグを開発者自身に割り当てます。
4. 課題に対する変更がマスターにコミットされる、あるいは検討が完了して
   開発者が気づいた点を課題として追加すると、ステータスが**Resolved**に変更され、
   新たにオープンされた課題がそれぞれに割り当てられます。

## コーディング基準

* パブリックバウンダリ(public boundary)(訳注：publicアクセサーが指定されて、
  外部からアクセスされることがあるメソッドやプロパティなどのこと)
  ではプレーンなコードを使用してパラメーターを検証します。
  コードコントラクトやマジックヘルパーを使用してはいけません。
  ```csharp
  if (argument == null)
  {
      throw new ArgumentNullException("argument");
  }
  ```
* コンパイラーのホットパス(訳注：頻繁に実行されることになるコード)では
  アロケーションを避けるようにします。
  * LINQを使用しないようにします。
  * 構造的な列挙子を持たないコレクションに対してforeachで全走査しないようにします。
  * オブジェクトプールを使用することを検討します。
    コンパイラー内にはオブジェクトプールの様々な用法のサンプルが見つかります。
* ソースファイルではタブ文字を使用しないようにします。
  標準のインデントレベルは半角空白4文字です。
  Visual Studio上であれば[編集]-[詳細]にある[選択行のタブの設定を解除]を使用して
  タブを削除できます。
  また[編集]-[詳細]にある[スペースの表示]を有効にすることで正しい設定を
  使用しているか確認することもできます。
* インターフェイスの名前は必ず「I」から始まるようにします。
  たとえば`ISomeInterface`のようにします。
* 型、メソッド、プロパティ、定数、イベント、publicフィールドでは必ず
  PascalCaseを使用します。
  たとえば`ThisIsAPascalCaseName`のようにします。

## コードフォーマット

一般的には変更箇所付近にあるコードのスタイルに準拠してください。
現時点において、以下のガイドラインが100%チームで準拠されているわけではありませんが、
チームでは基本的には以下のルールに従うようにしています。

### C♯

* チームでは http://en.wikipedia.org/wiki/Indent_style で定義されているBSD/Allman
  スタイルを採用しています。
  コントロールステートメントに関連する波括弧は次の行に置き、
  コントロールステートメントと同じインデントレベルにします。
  波括弧中のステートメントは次のインデントレベルにします。
  ```csharp
  void Method(int x)
  {
    if (x == 1)
    {
      DoSomething();
    }
    else
    {
      DoSomethingElse();
    }
  }
  ```
* 直前の行が`if`ステートメントのような場合、省略可能であっても必ず
  波括弧を使用してコードブロックにします。
* メンバーアクセス演算子である`.`および`->`を除いて、
  すべての二項演算子の前後には空白を記述します。
* ローカル変数やパラメータ、非publicフィールドにはキャメルケースを使用します。
  たとえば`thisIsACamelCaseName`のようにします。
* リテラルを引数に指定する場合、それが何を意味するのかをはっきりさせるために
  名前付き引数を使用します。
  ただしメソッドに定義された順序と異なる順序で名前付き引数を指定してはいけません。
* 宣言部の右辺に型の名前が記述されていない状況では`var`を使用してはいけません。
  `var`の用例としては以下の通りです：
  * オブジェクト生成式：`var f = new Foo();`
  * キャスト：`var f = (Bar)b;`
  * 既知の拡張メソッド`Cast`を使用する場合：`var f = b.Cast<Bar>();`
  * `as`式：`var f = d as SomeType;`

### Visual Basic

C#のガイドラインはいずれもVisual Basicにも適合するため、
チームではVisual Basicでも共通のガイドラインを採用しています。
空白の扱い、インデント、パラメーター名、名前付きパラメータの使用については
一般的にはVisual Basicでも同じでえす。
`Dim`ステートメントはC#の`var`に関するガイドラインに準じます。
Visual Basic固有のガイドラインとして、フィールド名は
`m_`または`_`で始まるようにします。
また、チームでは型の定義の先頭部分にすべてのフィールド宣言が記述される形式が
好まれています。
Visual Studioのメンバー一覧ではVBのフィールドは表示されません。
型の先頭にそれらを配置することにより、ナビゲーション機能を活用できます。
